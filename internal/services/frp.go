package services

import (
	"fmt"
	"strconv"
	"strings"
	"sync"

	"github.com/google/uuid"
	"tunnel-api/internal/models"
)

// FRPService manages FRP server-side proxy registrations
// Note: This is a simplified implementation. In production, you would
// communicate with frps via its admin API or manage config files.
type FRPService struct {
	serverAddr string
	serverPort int
	token      string
	domain     string
	
	// Track active proxies (in production, use frps admin API)
	activeProxies map[string][]string // runID -> proxy names
	mu            sync.RWMutex
}

func NewFRPService(serverAddr string, serverPort int, token, domain string) *FRPService {
	return &FRPService{
		serverAddr:    serverAddr,
		serverPort:    serverPort,
		token:         token,
		domain:        domain,
		activeProxies: make(map[string][]string),
	}
}

// RegisterProxies registers proxies for a tunnel's ports
// Returns a run ID to track this registration
func (f *FRPService) RegisterProxies(subdomain string, ports []models.TunnelPort) (string, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	runID := uuid.New().String()
	var proxyNames []string

	for _, port := range ports {
		proxyName := fmt.Sprintf("%s-%s-%d", subdomain, port.Label, port.PublicPort)
		proxyName = strings.ToLower(strings.ReplaceAll(proxyName, " ", "-"))
		proxyNames = append(proxyNames, proxyName)
	}

	// In a real implementation, you would:
	// 1. Call frps admin API to register proxies, OR
	// 2. Use frp's SDK to dynamically add proxies, OR
	// 3. Generate config and reload frps
	
	// For now, we just track the registration
	// The actual tunneling happens when the client connects with frpc
	f.activeProxies[runID] = proxyNames

	return runID, nil
}

// StopProxy removes proxies associated with a run ID
func (f *FRPService) StopProxy(runID string) {
	f.mu.Lock()
	defer f.mu.Unlock()

	// In production, call frps admin API to remove proxies
	delete(f.activeProxies, runID)
}

// GenerateClientConfig creates frpc TOML config for the client
func (f *FRPService) GenerateClientConfig(subdomain string, ports []models.TunnelPort) string {
	var sb strings.Builder

	// Common section
	sb.WriteString("# FRP Client Configuration\n")
	sb.WriteString("# Generated by MineDash Tunnel Service\n\n")
	sb.WriteString("[common]\n")
	sb.WriteString(fmt.Sprintf("server_addr = \"%s\"\n", f.domain))
	sb.WriteString(fmt.Sprintf("server_port = %d\n", f.serverPort))
	sb.WriteString(fmt.Sprintf("token = \"%s\"\n", f.token))
	sb.WriteString("\n")

	// Proxy sections for each port
	for _, port := range ports {
		proxyName := fmt.Sprintf("%s-%s", subdomain, strings.ToLower(strings.ReplaceAll(port.Label, " ", "-")))
		
		sb.WriteString(fmt.Sprintf("[[proxies]]\n"))
		sb.WriteString(fmt.Sprintf("name = \"%s\"\n", proxyName))
		sb.WriteString(fmt.Sprintf("type = \"%s\"\n", port.Protocol))
		sb.WriteString(fmt.Sprintf("local_ip = \"127.0.0.1\"\n"))
		sb.WriteString(fmt.Sprintf("local_port = %d\n", port.LocalPort))
		sb.WriteString(fmt.Sprintf("remote_port = %d\n", port.PublicPort))
		sb.WriteString("\n")
	}

	return sb.String()
}

// GenerateServerConfig creates frps TOML config
func (f *FRPService) GenerateServerConfig() string {
	var sb strings.Builder

	sb.WriteString("# FRP Server Configuration\n")
	sb.WriteString("# Place this in /etc/frp/frps.toml on your VPS\n\n")
	sb.WriteString(fmt.Sprintf("bindAddr = \"%s\"\n", f.serverAddr))
	sb.WriteString(fmt.Sprintf("bindPort = %d\n", f.serverPort))
	sb.WriteString(fmt.Sprintf("auth.token = \"%s\"\n", f.token))
	sb.WriteString("\n")
	sb.WriteString("# Dashboard (optional, for monitoring)\n")
	sb.WriteString("webServer.addr = \"0.0.0.0\"\n")
	sb.WriteString("webServer.port = 7500\n")
	sb.WriteString("webServer.user = \"admin\"\n")
	sb.WriteString("webServer.password = \"change-this-password\"\n")
	sb.WriteString("\n")
	sb.WriteString("# Allow port range for tunnels\n")
	sb.WriteString("allowPorts = [\n")
	sb.WriteString("  { start = 20000, end = 30000 }\n")
	sb.WriteString("]\n")

	return sb.String()
}

// GetActiveProxyCount returns the number of active proxy registrations
func (f *FRPService) GetActiveProxyCount() int {
	f.mu.RLock()
	defer f.mu.RUnlock()
	return len(f.activeProxies)
}

// Helper
func itoa(i int) string {
	return strconv.Itoa(i)
}
